#리눅스 디렉토리 구조

"/(root)" : 리눅스 상에 존재하는 모든 파일과 디렉터리를 담고 있는 최상위 디렉터리
"/bin":리눅스의 기본 명령어가 들어 있는 디렉터리(명령어는 "실행파일")
"/boot":리눅스 커널의 메모리 이미지와 부팅 과정에 필요한 파일이 저장된 디렉터리
"/dev":장치 파일이 들어 있는 디렉터리
"/etc":시스템이나 사용자 관리를 위한 자료 파일이나 관리자용 명령들이 있는 디렉터리
"/home":관리자(root) 이외의 사용자의 홈 Directory가 생성되는 위치의 디렉터리
"/lib":각종 언어를 위한 라이브러리를 가지는 디렉터리
      (lib64는 64비트 라이브러리들이 존재하는 디렉터리)
"/media":Local Device를 이용하기 위한 디렉터리(CD/DVD)
"/mnt":Remote Device를 이용하기 위한 디렉터리(블루투스)
"/opt":동작과 관련된 추가 옵션 설정에 대한 내용이 저장되는 디렉터리
"/proc":커널과 프로세스 정보를 담고 있는 파일이 저장되는 디렉터리
"/root":관리자 홈디렉터리
"/run":운영체제 내에 구동중인 내용들이 담기는 디렉터리
"/sbin":관리자용 명령어가 저장되는 디렉터리
"/sys":시스템 관련 파일이 담겨지는 디렉터리
"/tmp":임시파일이 저장되는 공간
"/usr":용량이 크고 자주 사용되지 않는 파일들이 들어있는 디렉터리
"/var":Log와 같이 잦은 변경이 일어나는 파일이 저장되는 디렉터리

## 리눅스의 기본 명령어 사용법1

  명령어 형식
 1. [명령어]			- 단독으로 명령어만으로 사용하는 경우. 
   ex) pwd, ls(생략) ...

 2. [명령어] [경로] 			- 특정 경로에 명령어를 사용하는 경우 
   ex) ls / , ls /etc/  (cat"/"해당 디렉터리의 파일/디렉터리 정보를 출력)
        cd [경로]

 3. [명령어] [옵션] [경로]		- 특정 경로에 옵션이 부여된 명령어를 사용하는 경우 
   ex) ls -l / , ls -l /etc/


 기본 명령어 
 1. cd (Change Directory)   => 리눅스 상 디렉터리 이동하는 명령어 
   
   형식 
      cd [경로]

 2. pwd (Print Working Directory)  => 현재 작업 위치를 출력

==================================================

## 경로 결정 방법 2가지

 1) 절대 경로
  : 리눅스 파일 시스템의 최상위의 "/(root)"를 기준으로 모든 경로 정보를 다 입력하여 사용하는 것!

  ex)  cd /etc/ , cd /etc/sysconfig/ , cd /


 2) 상대 경로 
  : 리눅스 파일 시스템의 상대 경로는 현재 작업 중인 디렉터리를 기준으로 파일이나 디렉터리에 대한 
  상대적인 위치 정보를 사용하는 것!! 

  ". " : 현재 디렉터리를 의미함.
  ".. " : 이전(상위, 부모) 디렉터리를 의미함. 
  "~(사용자 계정)" : 사용자 계정의 홈디렉터리로 이동!!

======================================================

  3. ls[list] : 디렉터리 내에 목록을 출력하는 명령어 

    [형식]
     ls [옵션] [경로]

    (옵션) 
     -l  :  목록을 상세히 출력 
     -n : 소유권을 숫자값(UID/GID)으로 표현하여 출력
     -d : 지정한 디렉터리의 정보를 출력(디렉터리 내 목록을 출력하지 않음)
     -R : 디렉터리 하위경로까지 전부 출력
     -a : 모든 파일 디렉터리를 출력(숨김도 출력)
     -F : 파일이나 디렉터리의 기호를 표시(특성 표시)

(확인 실습)
 1)ls를 이용하여 /etc/ 디렉터리의 목록을 출력
  ls /etc/

 2)/etc/ 디렉터리 내에 ".", ".." 디렉터리 정보들이 나타나게 출력하세요. 
  ls -a 
 
 3)2번의 정보를 상세하게 출력하는 설정을 해보세요.
  ls -al
  *리눅스의 숨김 파일/폴더 => 파일/디렉터리명 앞에 "."이 있으면 숨김표시
 
 4)/etc/ 디렉터리 내에 파일을 특성 정보를 출력하는 옵션을 사용해야 출력
ㅣㄴ 
   뒤에 "/" : 디렉터리 
   뒤에 "@" : 심볼릭(윈도우즈의 바로가기 같은)
   뒤에 아무것도 없어요 : 일반 파일

 5)/etc/sysconfig/ 내에 서브 디렉터리에 대한 모든 파일이 표시될 수 있게 출력하는 명령어를 써보세요. 


  4. mkdir  : 디렉터리 생성 명령어 

   형식
     mkdir [옵션] [경로]

   (옵션)
    -p     : 상위 경로까지 모든 디렉터리를 생성(없다면!!!)
    -m {퍼미션} : 디렉터리 생성과 동시에 권한 설정!!
    *퍼미션(허가권) - Read(읽기), Write(쓰기), eXcute(실행)

 실습)
   ./data/(상위)
      |- /test/(중간)
           |- /dir1(하위)
           |- /dir2
           |- /dir3

1줄
 mkdir -p ./data/test/{dir1,dir2,dir3}

3줄
 mkdir -p ./data/test/dir1
 mkdir -p ./data/test/dir2
 mkdir -p ./data/test/dir3

5줄
 mkdir data
 mkdir data/test
 mkdir data/test/dir1
 mkdir data/test/dir2
 mkdir data/test/dir3


 5. rmdir : 디렉터리 삭제
     **빈 디렉터리만 삭제 가능함(파일이 존재하면 삭제X)

   [형식]
     rmdir [옵션] [경로]

   (옵션)
     -p :상위 경로도 같이 삭제 
         (단, 빈디렉터리만 삭제 가능함...)

  실습) /data 에 있는 모든 디렉터리를 삭제하세요(/data포함)

=======
 파일 생성... 

 6. touch : 파일이 없는 경우, 내용이 빈 파일을 생성
               파일이 있는 경우, 파일의 시간을 명령하는 명령어 

    [형식] 
     touch [옵션] [경로/파일]

    (옵션)  
      -a : 최근 파일 사용 시간만 변경(Access)
      -c : 파일이 존재하지 않는 경우 파일을 생성하지 않는 옵션 
      -m : 최근 파일 변경(수정) 시간만 변경함. (Modify)
      -t : 지정한 시간대로 파일의 시간을 변경
          시간 설정 형식 : MMDDhhmm[[CC]YY[.ss]] 등과 같은 형식으로 지정할 수 있음. 
	ex) touch -t 202009281217 test
      -r "파일" : 현재 시간 대신에 "파일"의 시간을 설정함. 
             ex) touch -r test lastyear  => test파일의 시간대를 lastyear에 설정

 실습) 사용자 testuser 홈디렉터리에 test1, test2, test3 빈파일을 생성하세요
  - test1절대경로
    -> touch /home/testuser/test1

  - test2상대경로(~사용)
    -> touch ~/test2

  - test3은 현재 위치를 기준으로(~사용안함)
    -> touch ./test3

  7. cp(copy) : 파일이나 디렉터리를 복사하는 명령어

    [형식]
      cp [옵션] [Source] [Destination]
  
    -Source : 원본 파일
    -Destination : 복사 위치/파일명

    (옵션)
     -a : 복사 대상 원본파일의 속성과 링크 정보등을 그대로 유지하면서 복사하는 옵션(-dpR)
     -d : 심볼릭 파일 자체를 심볼릭 링크 정보와 함께 복사할 때 사용
     -p : 모드, 소유자, 시간 등을 그대로 유지한 상태로 복사할 경우 사용.
     -R : 하위의 모든 디렉터리까지 복사하는 옵션 
     -f : 복사할 위치에 같은 이름의 파일이 존재하는 경우, 파일 삭제후 복사
     -i : 복사할 위치에 같은 이름의 파일이 존재하는 경우, 사용자에게 복사 여부를 확인하는 절차를 진행.
         (cp를 사용하면 alias로 cp -i가 동작함)
     -s : 복사하는 대신에 심볼릭 파일을 생성하는 옵션 
     -v(vebos) : 각 파일의 복사 상태 정보를 출력하고자 하는 경우 사용하는 옵션 
     -b : 복사하고자 할 때에 파일이 동일이름으로 존재하는 경우, 
        덮어쓰기 또는 원본을 지우고 복사할 때에 백업 파일을 생성하는 옵션 


  실습)) testuser 사용자 계정으로 홈디렉터리에서 실습
    1) /etc/sysconfig/selinux 파일을 OS/Linux 디렉터리를 생성하고, 해당 디렉터리에 복사하세요.

    2) /etc/sysconfig/selinux 파일을 OS/Linux 디렉터리 내에 "ufile03" 이름으로 복사

    3) /etc/sysconfig/selinux 파일을 OS/Linux 디렉터리 내에 "ufile04"이름으로 복사
      (* 파일의 속성과 링크 정보를 유지하면서 복사하세요!!)

    4) /etc/ 디렉터리 내에 있는 d(소문자)로 시작하는 파일과 디렉터리와 그 하위 모든 파일까지
      OS/Linux 디렉터리로 복사하세요. (조건!! 한줄 명령어로 처리함)

  정규 표현식 "*"의 의미를 이용한 대상 선정
   "*" => 0글자 이상의 모든 글자를 대상으로 함. 

   ex) d* : 시작 글자가 "d"인 경우
        *d : 마지막 글자가 "d"인 경우
       d*d: 처음과 마지막 글자가 "d"인 경우 


 8. rm(remove) :  파일이나 디렉터리(옵션을 사용할 경우)를 제거하는 명령어

    [형식]
      rm [옵션] [경로/파일]

    (옵션)
      -f  : 파일을 삭제시 확인 메시지를 출력하지 않도록 하는 옵션
      -r  : 디렉터리를 삭제할 경우에 사용하는 옵션

  testuser홈 디렉터리에 있는 OS디렉터리를 삭제... 
  rm -rf OS


  9. mv(move) : 파일/디렉터리을 이동하는 명령어로 옵션은 거의 cp와 비슷함. 
        
      mv명령어와 cp명령어의 차이점
       - mv : 원본 파일을 삭제
       - cp : 원본 파일을 삭제X


============ 문서의 내용을 출력하는 명령어 =================
 => head, tail, more, less, cat

 10. head : 파일의 내용을 위에서부터 출력(기본 10줄)

    [형식]
     head [옵션] [경로/파일]

    (옵션)
      -n(숫자) : 출력하고자 하는 줄의 숫자를 입력하면 해당 줄 만큼 출력


  11. tail : 파일의 내용을 뒤에서부터 출력(기본 10줄)

    [형식]
     tail [옵션] [경로/파일]

    (옵션)
      -n(숫자) : 출력하고자 하는 줄의 숫자를 입력하면 해당 줄 만큼 출력
      -F   : 실시간으로 추가로 작성되는 내용을 표기할 수 있음. 


  12. cat : 텍스트 파일의 내용을 출력 

    [형식]
     cat [옵션] [파일]

    (옵션)
      -b : 줄번호를 화면 왼쪽에 표시함. (단, 공백은 제외)
      -e : 제어문자를 ^형태로 출력하면서 각 행의 끝에 $를 추가
      -n : 줄번호를 화면 왼쪽에 표시함. 공백도 포함
      -s : 중복되는 빈 행은 하나의 빈 행으로 처리하여 출력

   예) cat /etc/sysconfig/selinux

  13. more : 화면 단위로 끊어서 출력 

    [형식]
     more [옵션] [파일]

    (옵션)
      +(숫자) : 파일에 숫자만큼 줄을 이동한 후에 화면에 출력
      -(숫자)  : 화면에 숫자만큼 줄을 끊어서 출력함. 


  14. less : 출력된 화면을 이동하면서 확인할 수 있는 명령어 
             (재검색 가능. 방향키 사용함)

   
==============================================
 ## 파이프( | )
 : 한 프로그램의 출력을 중간 파일 없이 다른 파일의 입력으로 바로 보내는 유닉스 매커니즘.
 "|"기호를 기준으로 왼쪽 명령어의 출력 결과를 오른쪽 명령어의 입력으로 보내는 기능.

  ex)  ls -l /etc/sysconfig | more -10
          #1                  -> #2

       ls -l /etc/sysconfig | cat -b | less
          #1                 -> #2   -> #3

  15. grep : 파일 내에  또는 입력값에서 특정 패턴 검색하는 명령어 

     [형식]
      grep [옵션] [검색패턴] [파일/경로]

     (옵션)
       -v  : 일치되는 내용이 없는 라인을 표시
       -l(소문자) : 일치되는 내용이 있는 파일의 이름만 표시
       -c  : 일치되는 내용이 있는 행의 갯수를 표시
       -n  : 일치되는 내용이 있는 행의 행번호와 함게 표시
       -i  : 패턴에 대소문자 구분하지 않음. 
       -e 표현(정규표현식) : 표현하는 하이픈 문자로 시작될 때에 사용. **egrep과 grep -E와 같음. 
       -f "파일" : 찾으려고하는 장이나 파일을 지시 

**grep에서 사용되는 검색 문자 패턴 정규 표현식
  "."	: 어떤 문자나 한 문자를 의미
  "*"	: 어떤 문자나 문자열의 길이 상관없이 모든 문자열을 의미함. 
  "^"	: 행의 시작 위치를 의미함. 
  "$"   : 행의 마지막 위치를 의미함. 
  "[]"  : 한문자 길의 패턴리스트 
          ex) [0-9] -> 0~9 , 
              [a-z] -> a ~ z
  "[^]"	: 지정된 문자들 이외의 문자들을 의미함.
         (^는 여집합을 의미함) 
          ex) [^0-9]
  "\"   : 위에 설명한 특수한 의미의 문자들을 문자 그 자체로 인식할 때 사용
         (ESCAPE, 특수 문자를 일반문자로 표현할때)
  "\<"  : 단어의 시작 위치를 의미함. 
  "\>"  : 단어의 마지막 위치를 의미함. 

(연습)파이프 포함 grep
/etc/ 디렉터리에 내용을 자세히 출력, 재 검색이 가능 디렉터리가 아닌 파일만 출력하는 명령어 조합을 만들어보세요. 

hint) "d"-디렉터리, "-"-일반파일, "ㅣ"-심볼릭

  ls -l /etc/  | grep -v "^d"  | less


=====================================================
## 리다이렉션
 표준 입출력 기능을 다루는 방법을 제공
   표준 입력 (0) --- 키보드
   표준 출력 (1) --- 모니터
   표준 에러 (2) --- 모니터 
 리다이렉션은 이런 표준 입,출력,에러등을 변경하여 사용하는 것이 가능하게 함. 
 리다이렉션을 이용하여 기본적으로 출력 결과를 모니터에 표시하지만, 파일에 기록하는 것이 가능하게 됨. 

 리다이렉션 연산자 : < , > , >>

 (사용 예)
 명령어 > 파일 : 파일이 없다면 생성, 기존 파일이 있다면 삭제후 결과를 출력(Write)
 명령어 >> 파일 : 파일이 없다면 생성, 기존 파일이 있다면 내용을 추가(Append)
 명령어 < 파일 : 파일에서 표준 입력을 받음
 명령어 2> : 에러의 방향을 바꿈
 명령어 1>&2 : 출력을 에러로 보냄
 명령어 2>&1 : 에러를 출력으로 내보냄

--------------------------------------
(실습) 리다이렉션 실습
 1. cat을 이용하여 Hi_Linux파일을 생성
   안에는 "Hello Linux"란 문자를 5개 생성


16. find : 파일 또는 디렉터리를 검색하는 명령어 

    [형식]
     find [경로-검색 위치] [옵션]

    (옵션)
      -name : 이름으로 검색
      -type : 파일의 형식 (d-디렉터리, f-파일)

    <추가 옵션>
      -uid UID : 지정한 UID값을 가지고 검색
      -gid GID : 지정한 GID값을 가지고 검색
      -empty : 비어 있는 파일을 검색
      -perm : 지정된 퍼미션(허가권)을 가진 파일을 검색
      -used 일자수(n) : 최근 n일 이후에 변경된 파일을 검색
      -user : 소유자를 기준으로 검색

    [검색 이후에 수행 작업 옵션]
      -exec "수행명령어" \;  => 검색한 파일을 대상으로 "수행 명령어"를 실행하는 옵션

========= find명령어를 확인하기 위한 실습 환경 구성 ===========
 - 관리자(root) 작업()
   1) 디렉터리 생성
    # mkdir -p -m 1777 /data/{backup,doc,hwp}
     결과 : /data/backup
                    /doc
                    /hwp
               
 - 사용자 전환 
     # su testuser   => testuser계정으로 전환     
   1) /data/backup 디렉터리로 이동하여 파일 생성
     (index.html, text.bak, accesslog)
    - index.html 내용 : welcome
    - accesslog 내용 : doc file

 - 관리자 전환(root)
   2) /data 디렉터리에 a.txt 파일을 생성
    - a.txt 내용 : hi, CentOS!!
                     Hello World!!!

===========================================
 ## find 명령어 연습

 1. a.txt 를 찾아라!!
 [root@localhost ~]# find / -name "a.txt"

 2. index.html인 파일을 찾아라!! (/data)
 [root@localhost ~]# find /data -name "index.html" -type f

 3. 홈디렉터리에 있는 서브 디렉터리를 포함하는 모든 파일을 출력 
 [root@localhost ~]# find ~

 4. /data 디렉터리 내에 있는 testuser사용자가 생성한 파일을 찾아라!!!
 [root@localhost ~]# find /data -user testuser

 5. root 계정이 소유한 a로 시작하는 파일만 /data에서 검색!!
 [root@localhost ~]# find /data -user root -name "a*" -type f

 6. testuser 계정 홈디렉터리 내에 있는 모든 파일을 검색!!
 [root@localhost ~]# find ~testuser -type f

 7. /data/ 디렉터리 내에 권한 1777인 파일 및 디렉터리를 검색!!
 [root@localhost ~]# find /data -perm 1777

 8. a.txt파일을 찾아서 파일 내 "Hello"글자를 검색 하세요!!(-exec)
 [root@localhost ~]# find / -name "a.txt" -exec grep -n "Hello" {} \;

 9. /home 디렉터리 내에 특정 사용자의 파일을 검색하여 상세히 출력 하세요!!
    (testuser사용자의 파일을 검색, 검색 결과를 상세히 출력)
 [root@localhost ~]# find /home -user testuser -type f -exec ls -l {} \;

 10. 특정 문자를 포함하는 파일 찾기와 그 문자가 속한 행 찾기 (검색 문자 : doc )
     (검색 위치는 /data/ )
 [root@localhost ~]# find /data -type f -exec grep -i "doc" /dev/null {} \;

 11. 특정 시점을 기준으로 수정된 모든 파일을 검색(-newer)
    ** -newer 옵션은 지정된 파일의 시간 이후에 생성된 파일을 출력
   (2023-06-07 16시 00분 기점으로 .... )
    -특정 시점을 가리키는 파일을 생성(touch)
      # touch -t 202306071600 findtest
    -생성된 파일을 통해서 이후 생성파일 검색
[root@localhost ~]# find /data -newer findtest

 12. 서버 내에 불필요한 bak파일을 삭제
    ".bak 백업 파일은 서버내에 존재하면 안되요... "
      # find / -name "*.bak" -exec rm -rf {} \;

 13. 서버 내에 불필요한 파일(accesslog)를 /tmp로 이동하기 
[root@localhost ~]# find / -name "accesslog" -exec mv {} /tmp \;

 14. 특정 용량 이상되는 파일을 모두 찾기!!! ( -size )
     10MB이상의 파일을 찾아서 자세히 보기!!!
[root@localhost ~]# find / -size +10000k -exec ls -l {} \;


=========================================================
  ## 날짜 및 시간
  17. cal : 달력을 출력하는 명령어 

  18. date : 날짜 및 시간 출력 
               ( 기준시 : 1970년 1월 1일 00시 ) +9

=========================================================
  ## 시스템 종료 및 재부팅 

  19. shutdown : 시스템을 종료하는 명령어 

   [형식]
    shutdown [옵션] [시간(n)-분단위, now] [comment]

    (옵션) 
      -h  	: 시스템 종료 ( halt , init 0 )
      -r  	: 시스템 재부팅 ( reboot, init 6)
      -k 	: 시스템 종료 로그 메시지 전송(Warnning 메시지 전송 -실제 종료 X)
      -c	: 시스템 종료 설정에 대한 취소  

=============================================================
  ## 리눅스 시스템의 런레벨

  # init를 이용하여 실행 레벨로 서버를 구동 시킬 수 있음. 

 레벨0 : 시스템 종료 ( halt, shutdown -h now )
 레벨1 : 싱글모드(관리모드) - 콘솔로만 접근 가능
          시스템 관리 또는 root 패스워드 변경하고자 할 경우에 사용하는 런레벨(init 1)
          윈도우즈 시스템의 안전모드와 비슷함. 
 레벨2 : NFS를 지원하지 않는 멀티유저 실행 모드(init 2)
 레벨3 : NFS를 지원하는 멀티유저 실행 모드(init 3)
 레벨4 : 사용하지 않는 실행 모드(init 4)
          (사용자가 별도로 지정하여 사용할 수 있음)
 레벨5 :  X윈도우(GUI) 환경으로 실행되는 멀티 유저 실행 모드 (init 5)
 레벨6 : 시스템 재부팅 (reboot, shutdown -r now)

============================================================
  20. vi(m) 편집기
  : 리눅스에서 사용되는 가장 대표적인 문서 편집기(기본 지원)
  윈도우즈 메모장과 비슷한 기능을 가지고 편집할 수 있음. 

  사용법 
  1) vi(m) 파일이름 : vi(m)로 파일을 열기 
  2) vi(m) + 파일이름 : 기존 파일 맨 마지막 라인에 커서를 위치 시킴 
  3) vi(m) +숫자(n) 파일이름 : 기존 파일의 원하는 라인(n행)부터 커서 위치 시킴
  4) vi(m) +/문자열 파일이름 : 기존 파일의 원하는 문자열부터 커서 위치 시킴

  **VI편집기 모드(3가지)
  1) 입력모드 : 글자를 입력할 수 있는 모드 
  2) 명령모드(default) : 파일을 편집할 수 있는 작업이 가능한 모드 
  3) 실행모드 : 파일 저장, 읽기, 외부 명령 실행, 종료 등을 수행할 수 있는 모드 

  **모드간 이동
   각 모드별 직접 연결된 모드간에 이동이 가능함. 하지만, 건너뛰어 이동하는 것은 불가. 

  입력 모드 	<=> 	명령모드(default)	<=>	실행모드
     	    	=> 	"ESC"키 입력         <=
   a,A,i,I,o,O           <=			  => 	":"

=========================================================
 
  1. 커서의 이동  
       => 방향키를 사용!!
     k : 위로 이동
     j : 아래 이동
     h : 왼쪽 이동
     l : 오른쪽 이동


  2. 행단위 이동
     ^ : 행에 맨 왼쪽의 첫글자로 커서 이동
     $ : 행에 마지막 글자의 위치로 커서 이동
     G : 파일의 마지막 행
     nG : n번째 행으로 이동
     [[ : 커서를 파일의 맨 처음으로 이동
     ]] : 커서를 파일의 맨 마지막 행으로 이동

  3. 입력모드(글자입력 모드) - a,A,i,I,o,O
     a(커서 바로 다음부터 편집)
     A(커서를 행의 마지막으로 이동 후 편집)
     i(커서 위치에서 편집)
     I(커서를 행의 처음으로 이동 후 편집)
     o(커서 아래에 행을 추가하고 편집)
     O(커서 위에 행을 추가하고 편집)


4. 명령모드(ESC) => 문서 편집 
  x : 한글자씩 삭제
  b : 한단어씩 뒤로 이동
  db : 한단어씩 뒤로(왼쪽) 삭제
  dd : 한줄(행) 삭제
  ndd : n(숫자) 만큼 행을 삭제
  yy : 한줄(행) 복사
  nyy : n(숫자) 만큼 행을 복사
  p : 현재 커서 아래에 붙여넣기
  P : 현재 커서 위치에 붙여넣기
  np : n(숫자)만큼 행을 붙여넣기
  dw : 커서위치 한단어 삭제
  D : 커서 위치에서 라인 마지막까지 삭제
  ndw : n(숫자) 단어 삭제
  nx : n(숫자) 글자만큼 삭제
  y$ : 커서의 위치에서 라인 마지막까지 복사
  u : 마지막 변경된 내용 취소
  U : 현재 행에서 변경된 내용 모두 취소
  

 5. 단어 검색하기 
   /(단어) : 문서내에 단어를 위에서 아래로 검색

   ?(단어) : 문서내에 단어를 아래에서 위로 검색

  n - 진행방향으로 다음 단어 검색
  N - 진행 반대방향으로 다음 단어 검색 

 6. 치환(찾아서 바꾸기) : 문서상에 특정 단어를 찾아서 새로운 단어로 변경하는 것!!

   [사용형식]
  :[n]s/old/new 
   n - 라인(행)
   old - 이전단어(검색 단어)
   new - 새로운 단어(변경할 단어)

   ex) 
   :39s/PASS/Word   => 39줄에 있는 PASS => Word로 변경
   :34,42s/PASS/Word  => 34 ~ 42줄에 있는 PASS => Word로 변경
   :%s/PASS/Word    => 문서 전체에 있는 PASS => Word로 변경
 "/g"옵션 : 전부를 의미함.
 "/i" 옵션 : 대소문자 구분하지 않음. 

 7. 실행모드(:)
 :w => 파일 저장
 :q => 종료
 :wq => 파일을 저장하고 종료
 :{}! => 강제 실행({} 명령) ex) q!
 :x => 저장하고 종료
 :e 파일명 => "파일명"의 파일을 불러들여서 기존 파일 대체
 :r 파일명 => "파일명"의 파일을 불러들여서 현 커서 위치에 추가 
 :nr 파일명 => "파일명"의 파일을 불러들여서 n줄 이후에 추가
 :!명령어 => 외부 명령어를 실행
   ex) :!ls -l => ls -l을 터미널에서 사용한 것과 같은 출력 결과
 :e! => 현재 문서 내에서 변경한 모든 내용을 취소 (문서를 다시 불러와 준다)
 :set nu => 편집 문서에 행번호를 표기
 :set nonu => 편집 문서에 행번호를 표기 제거(비활성화)
 :set ai => 자동 들여쓰기
 :set wrap => 자동 줄바꿈 설정
 :set ts=숫자 => 탭키를 숫자만큼 공간으로 설정하기(기본 8자)
 :n => n(숫자)번째 행으로 이동
 :f => 현재 파일 정보를 확인

 추가
 :1,$y => 파일 전체 복사    
 :1, $ => 1줄부터 마지막줄까지 
 :10,15 => 10줄부터 15줄까지... 
 :-5,+5y => 현재 커서 위치에서 5줄 이전부터 5줄 이후까지 복사
 :3,.  => 3줄부터 현재 커서 위치까지
 :.,$  => 현재 커서 위치에서 마지막까지
 :.,$-2 => 현재 커서 위체서 마지막 라인 2줄 이전까지 

실습)) VI편집기 실습

[사전작업] - root로 작업(#)
mkdir -p /test/viTest   -> /test/viTest 디렉터리를 생성
cd /test/viTest 
cp /etc/login.defs /test/viTest/login.defs

** 실습할 파일 : /test/viTest/login.defs
테스트 조건 : 절대로 vi(m)나와서 작업하지 않습니다. 오직 vi(m) 내에서 모든 작업 진행!!!

1) /test/viTest/ 디렉터리 하위에 파일 A, B, C를 생성!
:!touch /test/viTest/{A,B,C}

2) 치환 작업 : 'PASS(->word)', 'number(->PASS)' 단어를 치환... 
:%s/PASS/word/g
:%s/number/PASS/g

3) 5 ~ 12번째 라인을 2번째 라인 밑에 복사
:5,12y
:2
p

4) 14번째 라인으로 이동 후에 ls -l /var/log/의 명령어 결과를 문서 내용으로 추가!!
:14
:r !ls -l /var/log/

5) 편집한 내용을 저장[종료는 하지 않음]
:w

6) 현재 열려있는 파일의 내용을 비어 있는 /test/viTest/B 파일에 입력 후에 B파일을 열어 내용 입력이 되었는 확인
1) :!cat /test/viTest/login.defs > /test/viTest/B
   :e /test/viTest/B
2) : w! /test/viTest/B
   : e /test/viTest/B

7) 현재 열려있는 B파일의 내용을 수정![치환 작업X] UID 단어를 찾아 UID를 수동으로 지워준 다음, 
  Xwindow라는 내용으로 변경 후에 저장(UID -> Xwindow로), /backup 디렉터리를 생성 END 이름으로 파일을 추가 저장
/UID
수정 UID => Xwindow로 수정
:w
:!mkdir /backup
:w /backup/END


8) 현재 vi 화면에서 새로운 문서를 불러온 후에 "안녕하세요!" 내용을 입력한 후에 /backup/END 파일을 불러오기. 
단, 현재 새로만들기로 이용해서 불러온 문서는 별도로 저장하지 않습니다. 
:enew!
"안녕하세요!"
:e! /backup/END


21. su : 사용자 전환 명령어 

    [형식]
      su 계정명

     일반계정 -> root, 다른 일반계정 : 인증을 필요함
     root -> 다른 일반계정으로 전활 : 인증이 불필요함.    


  22. sudo : 제한적 관리자 권한 사용 명령어. 관리자 권한으로 명령을 실행해야 하는 경우 

    [형식]
      sudo [옵션] or [명령어-관리자 권한으로 실행할 명령어]

    (옵션)
      -i    : 해당 터미널에서 관리자 권한 세션으로 처리

   **sudo 는 관리자 권한을 사용할 수 있는 설정이 되어 있는 경우에만 사용이 가능함.**

    sudo 설정 변경은 "visudo"를 통해서 변경이 가능함.( 설정파일의 위치 : /etc/sudoers ) 

=====================================================
=====================================================
## 사용자 관리(*****)
  : 리눅스의 사용자 관리란? 리눅스에서 사용되는 계정관리를 의미함. 
   리눅스에서 가장 중요한 부분 중 하나

1. /etc/passwd  : 사용자 정보가 저장되는 파일

user1:x:1000:1000:user1:/home/user1:/bin/bash

1번째 필드 : 계정명 필드("user1")
2번째 필드 : password필드. x표시는 여기에 기록되지 않을 것을 의미함. 
3번째 필드 : UID필드(계정을 식별하는 ID값이 기록됨)
4번째 필드 : GID필드(그룹 계정을 식별하는 ID값이 기록됨)
5번째 필드 : Comment 필드로 별칭이나 설명등이 저장된 필드
6번째 필드 : 홈 디렉터리 필드(계정의 홈디렉터리 경로를 표기함)
7번째 필드 : Shell필드(사용자가 사용하는 shell을 표기함.)

Shell? 리눅스 명령어 해석기
 리눅스 시스템은 하드웨어를 제어하는 "커널(Kernel)"을 가지고 있고, 이 커널을 통해서 
제어된 내용을 보다 쉽게 사용할 수 있는 정보로 제공하는 것이 바로 Shell이다. 

리눅스 쉘에 대한 정의파일(/etc/shells)
# cat /etc/shells
/bin/sh(/usr/bin/sh) : 최초 개발된 쉘
/bin/bash(/usr/bin/bash) : 리눅스 CentOS버전의 기본 쉘
/bin/tmux(/usr/bin/tmux)
/bin/zsh(/usr/bin/zsh)
---
/bin/ksh  : Unix에서 자주 사용되는 쉘
* /sbin/nologin : 로그인 하지 않는 사용자를 위한 쉘

2. /etc/group : 그룹 정보를 담고 있는 파일

# grep "^user1" /etc/group
user1:x:1000:

1번째 필드 : 그룹명(user1 그룹명)
2번째 필드 : 그룹에 대한 패스워드, x는 다른 곳에 패스워드 저장함.
3번째 필드 : 그룹ID(GID)
4번째 필드 : 그룹의 구성원

3. /etc/shadow : 사용자의 패스워드 및 계정 정책에 대한 내용이 존재함. 

# grep user1 /etc/shadow
user1:$6$7xWQF1x0XqDBkfqi$jiMNTb...(생략)...ysH0::0:99999:7:::

1번째 필드 : 사용자 계정명(user1)
2번째 필드 : 패스워드 필드(sha512 해쉬함수를 사용한 결과값)
  해쉬함수란? 단반향 함수로 특정 길이의 값으로 연산된 결과를 출력함. 
     해쉬함수 값의 특징은 해쉬값을 원래의 문자열로 되돌릴 수 없다. 
     해쉬값에 글자 하나라도 변경되면 값의 차이를 확실히 알 수 있음. 
3번째 필드 : 패스워드 최초 생성일(단위-day, 기준시-1970년 1월 1일)
4번째 필드 : 패스워드 최소 사용기간
5번째 필드 : 패스워드 만료 기간
6번째 필드 : 패스워드 만료 경고 시점
7번째 필드 : 만료 시점 이후에 계정으로 접속할 수 있는 기간(INACTIVE값)
8번째 필드 : 사용자 계정 만료 시점
9번째 필드 : 사용하지 않는 필드로 Flag필드

4. /etc/gshadow : 그룹 패스워드와 그룹관리자에 대한 정보를 저장한 파일

grep "^user1" /etc/gshadow
user1:!::

1번째 필드 : 그룹명
2번째 필드 : 패스워드(해쉬값)
3번째 필드 : 그룹의 관리자
4번째 필드 : 그룹의 구성원

** 패스워드 필드에 사용되는 값
"!!" : 해당 계정은 잠긴 상태로 로그인 불가능
" "  : 공백인 경우에는 패스워드가 설정되어 있지 않은 상황
"*" : no password로 시스템 및 어플리케이션 계정 용도로 로그인 못하는 계정

5. /etc/default/useradd : 사용자 생성시 기본값을 정의한 파일(useradd명령어의 기본 설정정보)

# cat /etc/default/useradd 
# useradd defaults file
GROUP=100		# 기본 그룹 ID
HOME=/home		# 사용자 홈 디렉터리 경로 지정
INACTIVE=-1		# 사용자 패스워드 사용기간 만료 후에 계정 사용 불가능해지는 시점
			# "0"이면 바로 사용 불가능, "-1"이면 이 기능 사용하지 않음. 
EXPIRE=			# 사용자 계정 만료일 지정(형식 : YYYY-MM-DD)
SHELL=/bin/bash		# 사용자 로그인시 사용할 기본 쉘 설정
SKEL=/etc/skel		# 사용자 계정 생성시 홈디렉터리에 생성되는 환경 파일을 지정
CREATE_MAIL_SPOOL=yes	# 새로 생성되는 계정의 메일 저장 파일 생성여부 결정

6. /etc/login.defs : 사용자 및 패스워드에 관한 설정 값에 대한 정의가 저장된 파일 


- MAIL_DIR 		/var/spool/mail	=> 각 계정사용자들의 메일파일이 저장될 위치를 지정
- PASS_MAX_DAYS		99999		=> 계정사용자들이 패스워드를 변경하지 않고 동일한 패스워드를 지속적으 로 사용할 수 있는 최대일자
- PASS_MIN_DAYS		0		=>  패스워드 변경없이 사용할 수 있는 최소일자 
- PASS_MIN_LEN		5		=> 각 계정사용자들이 패스워드문자로 지정할 수 있는 최소바이트수(영문자수) 
- PASS_WARN_AGE		7		=>  패스워드 종료일자가 다가오기 몇일 전 부터 패스워드 사용불가에 대한 안내메시지를 알려줄 것인가를 지정 
- UID_MAX		60000		=> 리눅스 서버에서 생성할 수 있는 UID의 최대값 
- UID_MIN		1000		=> 일반사용자의 UID번호를 할당할 때에 자동 할당할 최소 UID번호를 지정 
- GID_MAX		60000		=> 새로 생성되는 그룹에서 지정할 수 있는 최대 GID번호 
- GID_MIN		1000		=> 새로 생성되는 그룹의 GID 시작번호 
- CREATE_HOME		yes		=> 새로 생성되는 계정사용자의 홈디렉토리를 생성할 것인가를 결정
- UMASK			077		=> 퍼미션이 설정되지 않은 경우 지정된 퍼미션으로 설정(기본 022 권한)
- USERGROUPS_ENAB	yes		=> 사용자 대상 그룹을 활성화. 삭제 대상 사용자의 그룹이 존재하다면 그 그룹도 함께 삭제
- SHA512_CRYPT_ENAB	yes		=> 비밀번호 암호화 방식을 활성화

7. /var/spool/mail : 사용자 mail함 파일이 생성되는 디렉터리 

# ls -l /var/spool/mail
합계 0
-rw-rw----. 1 rpc   mail 0  9월 27 13:23 rpc
-rw-rw----. 1 user1 mail 0  9월 27 13:28 user1

8. /etc/skel : 사용자의 홈디렉터리를 구성하는 환경 파일이 저장되는 디렉터리 
 .bash_logout : 로그 아웃시 실행할 명령어를 기록
 .bash_profile : 해당 사용자의 패스(Path) 같은 환경 변수 등록
    (/etc/profile : 리눅스 시스템 전체 사용자들에게 적용되는 환경 변수가 여기에 있음)
 .bashrc : Alias 등록할 수 있는 파일

9. /home/ : 사용자 생성시 사용되는 기본 홈 디렉터리 생성 위치


## 사용자 추가 명령어(useradd) - 관리자 권한

  [형식]
    useradd [옵션] 계정명

   (옵션)
    -u UID, -g GID : UID, GID값을 지정하여 계정 생성시 사용하는 옵션 
    -c 	: Comment 지정하는 옵션
    -d    	: 홈디렉터리 지정하여 생성하는 옵션 
    -s	: 사용자에게 부여할 shell 종류를 지정(/etc/shells를 참고)
    -e	: 사용자 계정 만료 설정(YYYY-MM-DD 형식으로 지정함)
    -D	: useradd 기본 설정 정보 확인 (/etc/defaults/useradd)

   * -m -k : /etc/skel과 같은 스켈레톤 디렉터리를 지정할 수 있음. 
        **스켈레톤 디렉터리란? 홈디렉터리 생성시 사용할 정보를 가지고 있는 디렉터리를 의미함.  


(연습1)
  testuser2 계정생성, UID 1500으로 설정, 계정 만료일 설정 2023-7-31로 설정
 기본 쉘 설정을 /bin/sh로 설정하여 계정을 생성해 보세요!!!

 **잘 못 생성한 경우 계정 삭제 : userdel -r [계정명] **


(연습2) 
 -testuser3 계정 생성. 홈디렉터리 /testDir/testuser3, comment :테스트유저3

 ## 사용자 삭제 명령어( userdel)

   [형식]
    userdel [옵션] 계정명

   (옵션)
     -r :  홈디렉터리를 포함한 모든 계정 관련 파일을 삭제

(연습)
   userdel testuser2 삭제 후 정보 확인
   userdel -r testuser3 삭제 후 정보 확인 


 ## 사용자 정보 변경(usermod)

   [형식]
     usermod [옵션] 계정명

   (옵션) : 대부분 useradd옵션과 동일 
     -l  : 아이디[계정명]를 수정한 옵션 


(연습)
  testuser4를 생성
 1) testuser4의 UID값을 변경 ( => UID 1500 )
 2) testuser4의 home 디렉터리를 변경 ( => /home/testuser2 )
 3) testuser4의 shell 변경 ( => /bin/sh )
 4) testuser4의 계정명을 변경 ( =>  testuser5로 변경 )



## 사용자 패스워드 설정 관리(passwd)
  
   [형식] 
     passwd [옵션] [사용자 계정]

   (옵션)
     -S : 계정의 패스워드 상태를 출력 ( /etc/shadow )
     -l  : 계정의 패스워드 Lock설정(잠김)
     -u : 계정의 패스워드 Unlock설정(잠김 해제)
     -d : 계정의 패스워드 삭제
     **옵션이 없는 경우, 사용자 패스워드 설정 또는 변경
     **사용자 계정을 사용하지 않는 현재 작업 중인 사용자가 대상

(연습) 
   testuser5계정을 이용한 연습
   패스워드 생성(P@ssw0rd)
   # passwd testuser5
   (P@ssw0rd)


 1) 계정 상태 정보 보기 ( /etc/shadow 정보 비교 )
  # passwd -S testuser5

 2) 계정 패스워드 잠김
  # passwd -l testuser5

 3) 계정 패스워드 잠김 해제
  # passwd -u testuser5

 4) 계정 패스워드 삭제 
  # passwd -d testuser5

==========================================================
 ## Group 생성, 수정, 삭제
   => 특정 권한에 대한 관리의 편의성을 위해서 사용함. 

  1) 그룹 생성 : groupadd 

    [형식] 
      groupadd [옵션] 그룹명

    (옵션)
      -g	: GID를 지정하여 생성
      -r	: 시스템 영역의 GID를 할당 받을 때 사용

연습) 
   testG1 그룹 생성			=> # groupadd testG1
   testG2 그룹 생성(gid:2000)		=> # groupadd -g 2000 testG2
   testG3_sys 시스템 그룹 생성	=> # groupadd -r testG3_sys

  생성된 그룹 확인 ( /etc/group , /etc/shadow )


  2) 그룹 삭제 : groupdel
   
    [형식]
      groupdel [옵션] 그룹명

    (옵션) : 있으나 별로 사용하지 않음.... 

연습)
   testG3_sys 그룹을 삭제 		=> #groupdel testG3_sys


  3) 그룹 수정 : groupmod

    [형식]
     groupmod [옵션] 그룹명

    (옵션)
      -g  : GID를 변경하는 옵션 

연습)
   testG1 그룹의 ID값을 1500으로 변경	=> #groupmod -g 1500 testG2

   # ls -ld /home/testuser2 


=======================================
# 그룹의 구성원 관리(gpasswd)

  [형식]
    gpasswd [옵션] 그룹명

   (옵션) 
     -a	: 단일 구성원 추가
     -M 	: 다수의 구성원 추가(계정별로 구분은 ","를 사용함)
     -d	: 단일 구성원 삭제


연습1) testG2 그룹에 testuser1, testuser5를 동시에 추가 
    이후에 testuser6만 따로 추가 

연습2) testG2 그룹에서 testuser1을 구성원에서 제거


=======================================
## 허가권(permission) ****

 @종류
   1) 일반 허가권
      r(ead)   : 읽기
      w(rite)  : 쓰기(수정)
      x(excute)  : 실행

   2) 특수 허가권
      s : setUID, setGID 권한
         setUID는 파일의 실행을 UID(소유자)의 권한으로 실행
         setGID는 파일의 실행을 GID(그룹)의 권한으로 실행
      t : sticky bit 권한
         공유 디렉터리에 대한 설정 권한. 파일의 삭제 권한을 소유자와 root에만 부여!!

  @허가권 적용
    : 파일/디렉터리에 따라서 적용 결과가 달리질 수 있음. 
   1)파일(File)인 경우
      r : 파일에 대한 내용 읽기 권한(파일 내에 있는 내용을 읽을 수 있는 권한)
      w : 파일에 대한 내용 쓰기 및 수정 권한
      x : 파일에 대한 실행 권한
   2)디렉터리(Directory)인 경우
      r : ls 명령어 실행에 대한 권한. 디렉터리 목록 읽기 
      w : 디렉터리 내에 있는 파일이나 디렉터리에 대한 추가, 삭제, 변경 권한.  
      x : cd 명령어에 대한 권한(디렉터리 내에 있는 파일/디렉터리에 대한 접근 권한)

------------------- 파일/디렉터리 정보 표기 -------------------------------

-rw-rw-r--. 1 user1 user1   62  9월 28 16:23 Hi_Linux
drwxrwxr-x. 5 user1 user1   42  9월 28 17:26 data

10개 자리중 첫번째 타입 : -, d, l, c, b ... 
나머지 9자리는 권한으로 설정. 3자리씩 묶어서 표현
  첫번째 3자리 :  사용자(소유자)
  두번째 3자리 :  그룹
  세번째 3자리 :  other(이외-사용자와 그룹 이외)
    
 8진수란? 한자리의 숫자가 0 ~ 7사이의 값으로 이뤄진 방식을 의미함. 

      2진수	퍼미션
======================
  0 : 000		---
  1 : 001		--x
  2 : 010 		-w-
  3 : 011		-wx
  4 : 100		r--
  5 : 101 		r-x
  6 : 110		rw-
  7 : 111		rwx

 ** UMASK : 허가권에 대한 기본값을 설정하는 것이 UMASK값이다. 
   파일 생성시 권한 666을 부여
   디렉터리 생성시 권한 777을 부여
   하는 경우에 UMASK값을 통해서 부여되는 권한에 대해서 설정 적용. 

   UMASK : 022

   파일 생성 권한 부여 : 666
 
               110 110 110
    umask   000 010 010
             -----------------
	  110 100 100  => 644

    디렉터리 생성 권한 부여 : 777
  
               111 111 111
    umask   000 010 010
             -----------------
	  111 101 101  => 755

=======================================================
[환경 구성]
1) root권한으로 실행(변경)
2) 테스트를 위한 계정(ptester)
3) 허가권 테스트할 디렉터리 생성
   mkdir -p /Per_DIR/ptester
4) 생성한 디렉터리로 이동 후 파일 생성
   cd /Per_DIR/ptester
   touch 1
   echo "A" > 1 
5) 생성한 파일을 복사하여 여러개 파일을 생성 ( 1 ~ 10번 파일을 복사 생성)
   cp 1 2
   cp 1 3
   ... 
   cp 1 10
6) /Per_DIR디렉터리 내에 있는 ptester디렉터리에 권한을 부여 (754 권한 부여)
   # chmod 754 /Per_DIR/ptester
7) root 사용자와 ptester사용자로 터미널 접속. 
   역할)  
     root : 권한 설정(변경)
     ptester : 권한 테스트

=============================
 ## 허가권 부여하는 명령어 : chmod

   [형식]
    chmod [권한] [대상:파일/디렉터리]

    권한 부여 방법 => 옵션
   1. 문자를 이용하는 방법

     "+" : 허가권 추가
     "-"  : 허가권 제거
   ---- 허가권 적용 대상 ----
     "u" : user(owner)
     "g" : group
     "o" : other

  ex) chmod u+w,g+w,o+w [대상 파일이나 디렉터리 지정]
    => 소유자(사용자)에 대한 쓰기권한 부여, 그룹에 쓰기권한 부여, other에 쓰기 권한 부여
   
      chmod u-w,g-x,o+w-x [대상 파일이나 디렉터리 지정]
    => 소유자(사용자)에 대해서 쓰기권한 제거, 그룹에 쓰기권한 제거, other에 쓰기권한 부여하고 실행권한 제거 


   2. 숫자(8진수)를 이용하는 방법
     
  ex) chmod 644 [대상 파일/디렉터리]
    => 유저에 대한 읽기/쓰기 권한, 그룹에 대한 읽기권한, ohter에 대한 읽기 권한 

=========================================================
 권한 테스트 
   root : 권한 변경
   ptester : 권한 테스트 계정


문제1) ptester디렉터리내에 읽기 권한만 있다면 
     파일 리스트를 볼 수 있을까? => (볼수 있음.. 접근X)

문제2) ptester디렉터리에 754권한인 경우, 해당 디렉터리로 이동가능 
     여부 확인. (이동은 cd를 이용해서 해당 디렉터리 이동) => 이동할 수 없음.

문제3) ptester 사용자가 ptester 디렉터리로 이동하려면 
      무슨 권한을 부여해야 할지 생각하고 권한 부여하여 
      접근 성공하세요. 

     chmod 751 /Per_DIR/ptester
     chmod 755 /Per_DIR/ptester
     chmod o+x /Per_DIR/ptester

문제4) ptester 디렉터리내에 파일의 내용이나 디렉터리 모든 정보를 
      보기 위해서 디렉터리 부여해야 할 허가권은? 

      r-x 권한이 필요함... (chmod o+r /Per_DIR/ptester)

문제5) ptester디렉터리에 "1"파일에 쓰기를 원합니다. 
      이때에 "1"파일에 주어야할 권한은???

      "w" 권한을 부여 (chmod 646 /Per_DIR/ptester/1)

문제6) ptester 디렉터리에 "1"파일을 삭제할 수 있나요? 
      삭제할 수 없음. 삭제할 수 있도록 권한을 부여하세요!!!
      그리고, 1번 파일을 삭제하세요~~ 

      디렉터리에 "w"권한이 있어야 디렉터리 내에 파일/디렉터리를 삭제할 수 있음. 
      chmod 753 /Per_DIR/ptester   or  chmod 757 /Per_DIR/ptester

문제7) 디렉터리에 읽기 권한이 없는 경우 touch명령어 사용할 
    수 있을까? (753인 경우)

      생성 가능함... 왜? 디렉터리에 w 가 설정되어 있어서

문제8) 디렉터리에 읽기 권한이 없는 경우 rm이나 mv명령어를 
   사용할 수 있나?
     
      가능하다... 

문제9) 파일에 권한이 (---)으로 쓰기 권한이 없어도 디렉터리에 (-wx)권한이 있다면, 
   파일을 삭제할 수 있음. (자기 자신의 파일 뿐 아니라 누구의 것이든지 삭제가 가능)
   디렉터리에 권한이 있어도 파일을 삭제할 수 없게 만들려면, sticky bit를 사용하여
   생성자(소유자)와 root이외에 삭제가 불가능하게 만들어 줄 수 있음.       

    # chmod 1753 /Per_DIR/ptester/


  == 특수 권한 설정 ==
   -setUID, setGID의 권한 설정
     1)문자를 이용하는 경우 
         u, g 에  +s 권한을 부여하면 됨.    ex) chmod u+s 대상파일/디렉터리

     2)숫자를 이용하는 경우 
        setUID설정 권한에 +4000     ex) 755권한 대상에 setUID설정시 권한 값은 "4755"
        setGID설정 권한에 +2000     ex) 755권한 대상에 setGID설정시 권한 값은 "2755"

   -sticky bit 설정
     1)문자를 이용하는 경우
         o(other)+t 권한을 부여하면 됨.    ex) chmod o+t 대상파일/디렉터리

     2)숫자를 이용하는 경우 
         sticky bit 설정은 권한에 +1000   ex) 755권한 대상에 sticky bit설정 값은 "1755"

   ** 특수 권한 설정 중에 "x"권한이 없는 경우
       특수 권한 표시는 대문자로 표기됨. 


 ## 소유권 : chown
   : 파일이나 디렉터리에 대한 소유권 설정(유저와 그룹을 변경할 수 있음)

   UID, GID 변경

   [형식] 
    chown [소유자]:[소유그룹] [대상 파일/디렉터리]
   ** 해당 파일이나 디렉터리의 소유자 또는 그룹을 지정하여 변경하겠다는 의미.

  ex) chown testuser1:root /Per_DIR

==========================================================
==========================================================
[[실습]]
다음에 주어진 표 대로 계정, 그룹 생성 및 소속원을 할당하세요. 

 사용자계정 및 그룹 생성
================================================================
  계정명 	| test1	| test2 	| test3 	| test4 	| test5 	| test6 	| test7
  UID	| 2101  	| 2102  	| 2103  	| 2104  	| 2105  	| 2106  	| 2107
================================================================
  그룹명 	| Linux 	| Windows	| Unix  	| Solaris	|
  GID   	| 3000  	| 3500    		| 4000 	| 4500   	|
  소속원 	| test1  	| test3   		| test5 	|        	|
        	| test2  	| test4   		| test6 	| test7  	|
================================================================

1. 다음과 같이 디렉터리를 생성하세요. 
   /ptest/data/OS/Linux
   /ptest/data/OS/Windows
   /ptest/data/OS/Unix
   /ptest/data/OS/Solaris


2. 디렉터리에 퍼미션을 설정하세요. 
  - /ptest/data/OS 디렉터리내의 파일을 누구나 볼 수 있고, 
   접근할 수 있다. 하지만, 쓰기 권한을 없게 설정하세요. 
  - Linux, Windows, Unix, Solaris 디렉터리의 퍼미션 설정은 다음과 같이 설정하세요. 

  drwxrwxr-- 2 root Linux   6  3월 24 09:20 /ptest/data/OS/Linux
  drwxrwxr-- 2 root Solaris 6  3월 24 09:20 /ptest/data/OS/Solaris
  drwxrwxr-- 2 root Unix    6  3월 24 09:20 /ptest/data/OS/Unix
  drwxrwxr-- 2 root Windows 6  3월 24 09:20 /ptest/data/OS/Windows

3. 이후 각 사용자 계정으로 test1 ~ test7로 디렉터리 접근 가능 여부를 
  파일명으로 표기하세요. 

 각 계정별로 접속 touch로 파일명 생성. (test1_access과 같은 형태로 파일 생성 ) 

=====================================================

### 프로세서 관리 ###
 프로세스는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말함. (위키백과)
 즉, 컴퓨터에서 현재 실행되고 있는 프로그램들의 목록을 말함. 

 프로세스 관리란, 현재 실행되고 있는 프로세스 목록을 보고, 프로세스를 제거하는 것을 의미함. 

 1. 실행중인 프로세스 확인 (ps-[process status]) : 프로세스 목록 보기

   사용하기 
    ps [옵션]

    (옵션)
      -e	:  모든 프로세스 보기
      -f	:  full-format으로 출력하기
      -l	:  long-format으로 출력하기
      -u	:  사용자 이름과 시작 시간 출력하기
      -x	:  로그인된 사용자 및 시스템 프로세스 출력하기
      -a	:  다른 사용자 프로세스 출력하기 

 가장 많이 사용하는 방식 : ps -ef (ps aux)
  
   ** ps -ef | grep "단어"  , ps -ef | more


 2. 프로세스 목록 보는 명령어 :  pstree 
    ** 프로세스간의 관계를 트리 구조로 표현하여 보여줌. 
     (부모-자식관계 출력)


 3. 실행중인 프로세스 확인 : top (프로세스 모니터링 프로그램)
  - 유닉스 계열 시스템에서 프로세스 목록을 CPU 사용률이 높은 것부터 보여주는 소프트웨어
  - 출력 내용
    1행 : 시스템의 가동시간과 평균 부하의 숫자를 출력 
    2행 : 현재 실행중이 프로세스들의 상황
    3행 : CPU의 사용에 대한 상황
    4행 : 메모리의 사용에 대한 상황 
    5행 : 스왑메모리의 사용에 대한 상황 

 # top 명령어 
  h  : 도움말(help)
  u > uid(사용자이름)  :  특정 사용자를 기준으로 정보 출력 
  d or s > 숫자(단위 초) : 변경 딜레이 시간 설정(기본 3초)
  k > PID : 특정 프로세스 종료 
  q : 나가기 

 # Sort 단축키 
 shift + p : CPU 사용율 순으로 정렬(기본)
 shift + m : 메모리 사용율 순으로 정렬
 shift + t : 실행 시간 순으로 정렬
 shift + b : 업타임 순서로 정렬 

 # 배치모드에서 사용하기 
 - 배치 모드에서는 모든 프로세스를 다 표시할 수 있음.
 - Report 작성시 필요함. 
 # top -b -n 1 -u user1   (예시)

 4. 프로세스 종료 : kill 명령어 

   ****kill 명령어 
     : 특정 프로세스에 특정 시그널을 보낸다. 

   *** 시그날 리스트 보기 
     kill -l(소문자 L) 
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 	5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM(기본)
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO		30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	

 9) SIGKILL : 정상 종료로 중지가 불가능한 경우에 강제 종료. 
15) SIGTERM : 정상 종료(기본값)

실습] 프로세스 종료하기 (root에서 종료)
 -test1 사용자의 프로세스 "cat > bbb" 를 강제 종료해 보세요
 -user1 사용자의 프로세스 "cat > aaa" 를 정상 종료해 보세요 

 bg : 백그라운 명령어
 fg : 포그라운 명령어 


=========================

# Timezone  변경.... 
1. timedatectl

 Asia/Seoul 시간대로 변경
$ sudo timedatectl set-timezone Asia/Seoul

2. /etc/localtime 변경

시간대 정보 있는 저장 공간
/usr/share/zoneinfo/ 안에 들어있음. 
서울은 /usr/share/zoneinfo/Asia/Seoul 이 파일로 심볼릭을 변경... 

1) /etc/localtime 을 삭제
sudo rm -rf /etc/localtime
2) 심볼릭 파일 생성 
sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime






